/*
 * Adapted from Phoenix Code (phcode-dev/phoenix)
 * Original License: GNU AGPL-3.0
 * 
 * Copyright (c) 2021 - present core.ai . All rights reserved.
 * Original work Copyright (c) 2012 - 2021 Adobe Systems Incorporated. All rights reserved.
 *
 * Adapted to ES6 modules for standalone use (2024)
 * Removed Phoenix/Brackets dependencies
 * Simplified for CSS selector extraction and matching
 */

/**
 * Set of utilities for simple parsing of CSS text.
 */

import * as TokenUtils from './TokenUtils.js';

const MAX_CONTENT_LENGTH = 10 * 1024 * 1024; // 10MB

/**
 * CSS selector, used to target specific elements
 * @type {string}
 * @constant
 */
export const SELECTOR = "selector";

/**
 * name of the property
 * @type {string}
 * @constant
 */
export const PROP_NAME = "prop.name";

/**
 * value of the specified property
 * @type {string}
 * @constant
 */
export const PROP_VALUE = "prop.value";

/**
 * url for import
 * @type {string}
 * @constant
 */
export const IMPORT_URL = "import.url";

/**
 * List of all bracket pairs that is keyed by opening brackets, and the inverted list
 * that is keyed by closing brackets.
 * @private
 * @type {{string: string}}
 */
const _bracketPairs = {
    "{": "}",
    "[": "]",
    "(": ")"
};

const _invertedBracketPairs = {
    "}": "{",
    "]": "[",
    ")": "("
};

/**
 * @private
 * Helper function to check whether the given text string has any non whitespace character.
 * @param {!string} text
 * @return {boolean} true if text has any non whitespace character
 */
function _hasNonWhitespace(text) {
    return (/\S/.test(text));
}

/**
 * Helper function to remove whitespaces before and after a selector
 * Returns trimmed selector if it is not an at-rule, or null if it starts with @.
 * @private
 * @param {string} selector
 * @return {string}
 */
function _stripAtRules(selector) {
    selector = selector.trim();
    if (selector.indexOf("@") === 0) {
        return "";
    }
    return selector;
}

/**
 * Converts the given selector array into the actual CSS selectors similar to
 * those generated by a CSS preprocessor.
 * @private
 * @param {Array.<string>} selectorArray
 * @return {string}
 */
function _getSelectorInFinalCSSForm(selectorArray) {
    let finalSelectorArray = [""];
    let parentSelectorArray = [];
    let group = [];

    selectorArray.forEach(function (selector) {
        selector = _stripAtRules(selector);
        group = selector.split(",");
        parentSelectorArray = [];

        group.forEach(function (cs) {
            const ampersandIndex = cs.indexOf("&");

            finalSelectorArray.forEach(function (ps) {
                if (ampersandIndex === -1) {
                    cs = _stripAtRules(cs);
                    if (ps.length && cs.length) {
                        ps += " ";
                    }
                    ps += cs;
                } else {
                    // Replace all instances of & with regexp
                    ps = _stripAtRules(cs.replace(/&/g, ps));
                }
                parentSelectorArray.push(ps);
            });
        });

        finalSelectorArray = parentSelectorArray;
    });

    return finalSelectorArray.join(", ");
}

/**
 * Return a string that shows the literal parent hierarchy of the selector
 * in info.
 *
 * @param {!SelectorInfo} info
 * @param {boolean=} useGroup true to append selectorGroup instead of selector
 * @return {string} the literal parent hierarchy of the selector
 */
export function getCompleteSelectors(info, useGroup) {
    if (info.parentSelectors) {
        // Show parents with / separators.
        let completeSelectors = info.parentSelectors + " / ";
        if (useGroup && info.selectorGroup) {
            completeSelectors += info.selectorGroup;
        } else {
            completeSelectors += info.selector;
        }
        return completeSelectors;
    } else if (useGroup && info.selectorGroup) {
        return info.selectorGroup;
    }
    return info.selector;
}

/**
 * @typedef {{selector: !string,
 *            ruleStartLine: number,
 *            ruleStartChar: number,
 *            selectorStartLine: number,
 *            selectorStartChar: number,
 *            selectorEndLine: number,
 *            selectorEndChar: number,
 *            selectorGroupStartLine: number,
 *            selectorGroupStartChar: number,
 *            selectorGroup: ?string,
 *            declListStartLine: number,
 *            declListStartChar: number,
 *            declListEndLine: number,
 *            declListEndChar: number,
 *            level: number,
 *            parentSelectors: ?string}} SelectorInfo
 */

/**
 * Extracts all CSS selectors from the given text
 * Returns an array of SelectorInfo. Each SelectorInfo is an object with the following properties:
     selector: the text of the selector (note: comma separated selector groups like "h1, h2" are broken into separate selectors)
     ruleStartLine: line in the text where the rule (including preceding comment) appears
     ruleStartChar: column in the line where the rule (including preceding comment) starts
     selectorStartLine: line in the text where the selector appears
     selectorStartChar: column in the line where the selector starts
     selectorEndLine: line where the selector ends
     selectorEndChar: column where the selector ends
     selectorGroupStartLine: line where the comma-separated selector group (e.g. .foo, .bar, .baz) starts that this selector (e.g. .baz) is part of. Particularly relevant for groups that are on multiple lines.
     selectorGroupStartChar: column in line where the selector group starts.
     selectorGroup: the entire selector group containing this selector, or undefined if there is only one selector in the rule.
     declListStartLine: line where the declaration list for the rule starts
     declListStartChar: column in line where the declaration list for the rule starts
     declListEndLine: line where the declaration list for the rule ends
     declListEndChar: column in the line where the declaration list for the rule ends
     level: the level of the current selector including any containing @media block in the nesting level count. Use this property with caution since it is primarily for internal parsing use. For example, two sibling selectors may have different levels if one of them is nested inside an @media block and it should not be used for sibling info.
     parentSelectors: all ancestor selectors separated with '/' if the current selector is a nested one
 * @param {!string} text CSS text to extract from
 * @param {?string} documentMode language mode of the document that text belongs to, default to css if undefined.
 * @return {Array.<SelectorInfo>} Array with objects specifying selectors.
 */
export function extractAllSelectors(text, documentMode) {
    // This is a simplified version that uses regex-based parsing
    // For production use, consider using a proper CSS parser like postcss
    
    const selectors = [];
    const lines = text.split('\n');
    let currentLevel = 0;
    let inComment = false;
    let inRule = false;
    let currentSelector = '';
    let ruleStartLine = -1;
    let selectorStartLine = -1;
    let declListStartLine = -1;
    
    // Simple regex-based extraction
    // This handles basic CSS but may not cover all edge cases
    const selectorRegex = /([^{};]+)\s*\{/g;
    
    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
        const line = lines[lineNum];
        
        // Skip comments (simplified)
        if (line.trim().startsWith('/*')) {
            inComment = true;
        }
        if (line.includes('*/')) {
            inComment = false;
            continue;
        }
        if (inComment) {
            continue;
        }
        
        // Find selectors
        const matches = line.matchAll(selectorRegex);
        for (const match of matches) {
            const selector = match[1].trim();
            
            // Skip @rules except @media
            if (selector.startsWith('@') && !selector.startsWith('@media')) {
                continue;
            }
            
            // Handle @media
            if (selector.startsWith('@media')) {
                currentLevel++;
                continue;
            }
            
            // Split comma-separated selectors
            const individualSelectors = selector.split(',').map(s => s.trim());
            
            individualSelectors.forEach(sel => {
                if (sel && !sel.startsWith('@')) {
                    selectors.push({
                        selector: sel,
                        ruleStartLine: lineNum,
                        ruleStartChar: line.indexOf(sel),
                        selectorStartLine: lineNum,
                        selectorStartChar: line.indexOf(sel),
                        selectorEndLine: lineNum,
                        selectorEndChar: line.indexOf(sel) + sel.length,
                        selectorGroupStartLine: lineNum,
                        selectorGroupStartChar: line.indexOf(match[1]),
                        selectorGroup: individualSelectors.length > 1 ? selector : undefined,
                        declListStartLine: lineNum,
                        declListStartChar: match.index + match[0].length - 1,
                        declListEndLine: -1,
                        declListEndChar: -1,
                        level: currentLevel,
                        parentSelectors: null
                    });
                }
            });
        }
        
        // Track closing braces
        const closingBraces = (line.match(/\}/g) || []).length;
        currentLevel = Math.max(0, currentLevel - closingBraces);
    }
    
    return selectors;
}

/**
 * Finds all instances of the specified selector in "text".
 * Returns an Array of Objects with start and end properties.
 *
 * For now, we only support simple selectors. This function will need to change
 * dramatically to support full selectors.
 *
 * @private
 * @param {!string} text CSS text to search
 * @param {!string} selector selector to search for
 * @param {!string} mode language mode of the document that text belongs to
 * @return {{selectorGroupStartLine:number, declListEndLine:number, selector:string}}
 *      Array of objects containing the start and end line numbers (0-based, inclusive range) for each
 *      matched selector.
 */
function _findAllMatchingSelectorsInText(text, selector, mode) {
    const allSelectors = extractAllSelectors(text, mode);
    const result = [];

    // For now, we only match the rightmost simple selector, and ignore
    // attribute selectors and pseudo selectors
    const classOrIdSelector = selector[0] === "." || selector[0] === "#";

    // Escape initial "." in selector, if present.
    let searchSelector = selector;
    if (selector[0] === ".") {
        searchSelector = "\\" + selector;
    }

    if (!classOrIdSelector) {
        // Tag selectors must have nothing, whitespace, or a combinator before it.
        searchSelector = "(^|[\\s>+~])" + searchSelector;
    }

    const re = new RegExp(searchSelector + "(\\[[^\\]]*\\]|:{1,2}[\\w-()]+|\\.[\\w-]+|#[\\w-]+)*\\s*$", classOrIdSelector ? "" : "i");

    allSelectors.forEach(function (entry) {
        let actualSelector = entry.selector;
        if (entry.selector.indexOf("&") !== -1 && entry.parentSelectors) {
            const selectorArray = entry.parentSelectors.split(" / ");
            selectorArray.push(entry.selector);
            actualSelector = _getSelectorInFinalCSSForm(selectorArray);
        }

        if (actualSelector.search(re) !== -1) {
            result.push(entry);
        } else if (!classOrIdSelector) {
            // Special case for tag selectors - match "*" as the rightmost character
            if (/\*\s*$/.test(actualSelector)) {
                result.push(entry);
            }
        }
    });

    return result;
}

/**
 * Finds matching selectors in CSS text and returns simplified results
 * @param {!string} text CSS text to search
 * @param {!string} selector Selector to search for
 * @param {?string} mode Language mode (css, less, scss)
 * @return {Array.<{name: string, lineStart: number, lineEnd: number, selectorGroup: string}>}
 */
export function findMatchingRules(text, selector, mode) {
    const matches = _findAllMatchingSelectorsInText(text, selector, mode || 'css');
    return matches.map(selectorInfo => ({
        name: getCompleteSelectors(selectorInfo),
        lineStart: selectorInfo.ruleStartLine,
        lineEnd: selectorInfo.declListEndLine,
        selectorGroup: selectorInfo.selectorGroup
    }));
}

/**
 * Extracts all class names from CSS text
 * @param {!string} text CSS text to parse
 * @return {Array.<string>} Array of class names (without the leading dot)
 */
export function extractAllClassNames(text) {
    const classNames = new Set();
    const selectors = extractAllSelectors(text);
    
    selectors.forEach(selectorInfo => {
        // Extract class names from selector using regex
        const matches = selectorInfo.selector.match(/\.([a-zA-Z0-9_-]+)/g);
        if (matches) {
            matches.forEach(match => {
                // Remove the leading dot
                classNames.add(match.substring(1));
            });
        }
    });
    
    return Array.from(classNames).sort();
}

/**
 * Extracts all ID selectors from CSS text
 * @param {!string} text CSS text to parse
 * @return {Array.<string>} Array of ID names (without the leading #)
 */
export function extractAllIds(text) {
    const ids = new Set();
    const selectors = extractAllSelectors(text);
    
    selectors.forEach(selectorInfo => {
        // Extract IDs from selector using regex
        const matches = selectorInfo.selector.match(/#([a-zA-Z0-9_-]+)/g);
        if (matches) {
            matches.forEach(match => {
                // Remove the leading #
                ids.add(match.substring(1));
            });
        }
    });
    
    return Array.from(ids).sort();
}

/**
 * Reduces a style sheet to remove comments and simplify for regex parsing
 * @param {!string} text CSS text to reduce
 * @return {string} Reduced CSS text
 */
export function reduceStyleSheetForRegExParsing(text) {
    // Remove block comments
    let reduced = text.replace(/\/\*[\s\S]*?\*\//g, '');
    
    // Remove line comments (for LESS/SCSS)
    reduced = reduced.replace(/\/\/.*/g, '');
    
    // Normalize whitespace
    reduced = reduced.replace(/\s+/g, ' ');
    
    return reduced.trim();
}

/**
 * Gets all selectors within a specific range
 * @param {!string} text CSS text
 * @param {{start: {line: number, ch: number}, end: {line: number, ch: number}}} range
 * @return {Array.<SelectorInfo>} Selectors within the range
 */
export function getRangeSelectors(text, range) {
    const allSelectors = extractAllSelectors(text);
    
    return allSelectors.filter(selector => {
        return selector.selectorStartLine >= range.start.line &&
               selector.selectorEndLine <= range.end.line;
    });
}

/**
 * Determines if the given path is a CSS preprocessor file
 * @param {string} filePath Path to check
 * @return {boolean} true if file is LESS or SCSS
 */
export function isCSSPreprocessorFile(filePath) {
    const ext = filePath.split('.').pop().toLowerCase();
    return ext === 'less' || ext === 'scss' || ext === 'sass';
}
